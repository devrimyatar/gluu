#!/usr/bin/env python
"""import2431.py - Script to import the backup into Gluu Server 3.0.x

Usage: python import2431.py <path_to_backup_folder>
Example: python import2431.py /root/backup_24

This script imports the data from backup folder generated by export2431.py.
Read complete migration procedure at:
    https://www.gluu.org/docs/deployment/upgrading/
"""

import os
import os.path
import sys
import logging
import traceback
import shutil
import json
import re
import subprocess
import time
import datetime
import base64
import pyDes
import ldap

from distutils.dir_util import copy_tree
from ldif import LDIFParser, LDIFWriter
from jsonmerge import merge

from ldifschema_utils import OpenDjSchema

ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_ALLOW)

# configure logging
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s %(levelname)-8s %(name)s %(message)s',
                    filename='import2431.log',
                    filemode='w')
console = logging.StreamHandler()
console.setLevel(logging.INFO)
formatter = logging.Formatter('%(levelname)-8s %(message)s')
console.setFormatter(formatter)
logging.getLogger('').addHandler(console)
logging.getLogger('jsonmerge').setLevel(logging.WARNING)


class MyLDIF(LDIFParser):
    def __init__(self, input, output):
        LDIFParser.__init__(self, input)
        self.targetDN = None
        self.targetAttr = None
        self.targetEntry = None
        self.DNs = []
        self.lastDN = None
        self.lastEntry = None
        self.entries = []

    def getResults(self):
        return (self.targetDN, self.targetAttr)

    def getDNs(self):
        return self.DNs

    def getLastEntry(self):
        return self.lastEntry

    def handle(self, dn, entry):
        if self.targetDN is None:
            self.targetDN = dn
        self.lastDN = dn
        self.DNs.append(dn)
        self.entries.append(entry)
        self.lastEntry = entry
        if dn.lower().strip() == self.targetDN.lower().strip():
            self.targetEntry = entry
            if self.targetAttr in entry:
                self.targetAttr = entry[self.targetAttr]


class Migration(object):
    def __init__(self, backup):
        self.backupDir = backup
        self.ldifDir = os.path.join(backup, 'ldif')
        self.certsDir = os.path.join(backup, 'etc', 'certs')
        self.currentDir = os.path.dirname(os.path.realpath(__file__))
        self.workingDir = os.path.join(self.currentDir, 'migration')
        self.jettyDir = "/opt/gluu/jetty/"
        self.os_types = ['centos', 'redhat', 'fedora', 'ubuntu', 'debian']
        self.os = self.detect_os_type()
        self.service = "/usr/sbin/service"
        if self.os is 'centos':
            self.service = "/sbin/service"

        self.slapdConf = "/opt/symas/etc/openldap/slapd.conf"
        self.slapcat = "/opt/symas/bin/slapcat"
        self.slapadd = "/opt/symas/bin/slapadd"
        self.keytool = "/opt/jre/bin/keytool"
        self.key_store = "/opt/jre/jre/lib/security/cacerts"
        self.ldif_import = "/opt/opendj/bin/import-ldif"
        self.ldif_export = "/opt/opendj/bin/export-ldif"
        self.ldif_search = "/opt/opendj/bin/ldapsearch"
        self.ldif_modify = "/opt/opendj/bin/ldapmodify"
        self.ldapHost = "127.0.0.1"
        self.ldapPort = "1636"
        self.baseDn = "cn=directory manager,o=gluu"
        self.ldappassowrd = None
        self.key = None
        self.oxAuthClientSecret = None
        self.idpDN = None
        self.encryptIdpJson = None

        self.ldapDataFile = "/opt/gluu/data/main_db/data.mdb"
        self.ldapSiteFile = "/opt/gluu/data/site_db/data.mdb"

        self.currentData = os.path.join(self.workingDir, 'current.ldif')
        self.o_gluu = os.path.join(self.workingDir, "o_gluu.ldif")
        self.processTempFile = os.path.join(self.workingDir, "temp.ldif")
        self.o_site_static = "/install/community-edition-setup/static/cache-refresh/o_site.ldif"
        self.o_site = os.path.join(self.workingDir, "o_site.ldif")
        self.attrs = 2000
        self.objclasses = 2000
        self.ldap_type = 'openldap'
        self.gluuSchemaDir = '/opt/gluu/schema/openldap/'
        self.backupVersion = 0
        self.setup_properties = 'backup_2431/setup.properties'
        self.customAttrs = []

    def slapdConfAdd(self):
        with open(self.slapdConf, 'a') as f:
            f.writelines("sizelimit -1")
            f.close

    def slapdConfremove(self):
        with open(self.slapdConf, 'a+') as f:
            lines = f.readlines()
            lines = lines[:-1]
            f.close

    def readFile(self, inFilePath):
        if not os.path.exists(inFilePath):
            logging.debug("Cannot read: %s. File does not exist.", inFilePath)
            return None

        inFilePathText = None
        try:
            f = open(inFilePath)
            inFilePathText = f.read()
            f.close
        except:
            logging.warning("Error reading %s", inFilePath)
            logging.debug(traceback.format_exc())

        return inFilePathText

    def walk_function(self, a, directory, files):
        for f in files:
            fn = "%s/%s" % (directory, f)
            targetFn = fn.replace(self.backupDir, '')
            if os.path.isdir(fn):
                if not os.path.exists(targetFn):
                    os.mkdir(targetFn)
            else:
                try:
                    logging.debug("copying %s", targetFn)
                    shutil.copyfile(fn, targetFn)
                except:
                    logging.error("Error copying %s", targetFn)

    def detect_os_type(self):
        distro_info = self.readFile('/etc/redhat-release')
        if distro_info is None:
            distro_info = self.readFile('/etc/os-release')
        if 'CentOS' in distro_info:
            return self.os_types[0]
        elif 'Red Hat' in distro_info:
            return self.os_types[1]
        elif 'Ubuntu' in distro_info:
            return self.os_types[3]
        elif 'Debian' in distro_info:
            return self.os_types[4]
        else:
            return self.choose_from_list(self.os_types, "Operating System")

    def verifyBackupData(self):
        if not os.path.exists(self.backupDir):
            logging.error("Backup folder %s doesn't exist! Quitting migration",
                          self.backupDir)
            sys.exit(1)
        if not os.path.exists(self.ldifDir):
            logging.error("Backup doesn't contain directory for LDIF data."
                          " Nothing to migrate. Quitting.")
            sys.exit(1)

    def setupWorkDirectory(self):
        if not os.path.exists(self.workingDir):
            os.mkdir(self.workingDir)
        else:
            # Clean the directory in case its already present
            shutil.rmtree(self.workingDir)
            os.mkdir(self.workingDir)

    def getOutput(self, args):
        try:
            logging.debug("Running command : %s" % " ".join(args))
            p = subprocess.Popen(args, stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE)
            output, error = p.communicate()
            if error and 'Certificate was added to keystore' not in error:
                logging.error(error)
            logging.debug(output)
            return output
        except:
            logging.error("Error running command : %s" % " ".join(args))
            logging.error(traceback.format_exc())
            sys.exit(1)

    def copyCertificates(self):
        # remove opendj.crt
        command = ['rm','backup_2431/etc/certs/opendj.crt']
        output = self.getOutput(command)

        logging.info("Copying the Certificates.")
        os.path.walk("%s/etc" % self.backupDir, self.walk_function, None)

        logging.info("Updating the CA Certs Keystore.")
        keys = ['httpd', 'idp-signing', 'idp-encryption', 'shibidp', 'asimba',
                'openldap']
        hostname = self.getOutput(['hostname']).strip()
        # import all the keys into the keystore
        for key in keys:
            alias = "{0}_{1}".format(hostname, key)
            filename = os.path.join(self.certsDir, key + ".crt")
            if not os.path.isfile(filename):
                logging.debug("Missing file: %s", filename)
                continue  # skip the non-existant certs

            logging.debug('Deleting new %s', alias)
            result = self.getOutput(
                [self.keytool, '-delete', '-alias', alias, '-keystore',
                 self.key_store, '-storepass', 'changeit', '-noprompt'])
            logging.error(result) if 'error' in result else logging.debug('Delete operation success.')

            logging.debug('Importing old %s', alias)
            result = self.getOutput(
                [self.keytool, '-import', '-trustcacerts', '-file', filename,
                 '-alias', alias, '-keystore', self.key_store, '-storepass',
                 'changeit', '-noprompt'])
            logging.error(result) if 'error' in result else logging.debug('Certificate import success.')

    def stopSolserver(self):
        logging.info("Stopping OpenLDAP Server.")
        stop_msg = self.getOutput([self.service, 'solserver', 'stop'])
        output = self.getOutput([self.service, 'solserver', 'status'])
        if "is not running" in output:
            return
        else:
            logging.error("Couldn't stop the OpenLDAP server.")
            logging.error(stop_msg)
            sys.exit(1)

    def startSolserver(self):
        logging.info("Starting OpenLDAP Server.")
        start_msg = self.getOutput([self.service, 'solserver', 'start'])
        output = self.getOutput([self.service, 'solserver', 'status'])
        if "is running" in output:
            return
        else:
            logging.error("Couldn't start the OpenLDAP server.")
            logging.error(start_msg)
            sys.exit(1)

    def copyCustomFiles(self):
        logging.info("Copying the custom pages and assets of webapps.")
        folder_map = [(os.path.join(self.backupDir, 'opt'), '/opt')]

        if self.version < 300:
            custom = self.backupDir + '/var/gluu/webapps/'
            folder_map = [
                (custom + 'oxauth/pages', self.jettyDir + 'oxauth/custom/pages'),
                (custom + 'oxauth/resources', self.jettyDir + 'oxauth/custom/static'),
                (custom + 'oxauth/libs', self.jettyDir + 'oxauth/lib/ext'),
                (custom + 'oxtrust/pages', self.jettyDir + 'identity/custom/pages'),
                (custom + 'oxtrust/resources', self.jettyDir + 'identity/custom/static'),
                (custom + 'oxtrust/libs', self.jettyDir + 'identity/lib/ext'),
            ]

        for pair in folder_map:
            copy_tree(pair[0], pair[1])

    def stopWebapps(self):
        logging.info("Stopping Webapps oxAuth and Identity.")
        stop_msg = self.getOutput([self.service, 'oxauth', 'stop'])
        status = self.getOutput([self.service, 'oxauth', 'status'])
        if 'Jetty NOT running' not in status:
            logging.error("Couldn't stop oxAuth.")
            logging.error(stop_msg)

        stop_msg = self.getOutput([self.service, 'identity', 'stop'])
        status = self.getOutput([self.service, 'identity', 'status'])
        if 'Jetty NOT running' not in status:
            logging.error("Couldn't stop Identity.")
            logging.error(stop_msg)

    def startWebapps(self):
        logging.info("Starting Webapps oxAuth and Identity.")
        start_msg = self.getOutput([self.service, 'oxauth', 'start'])
        status = self.getOutput([self.service, 'oxauth', 'status'])
        if 'Jetty running pid' not in status:
            logging.error("Couldn't stop oxAuth.")
            logging.error(start_msg)

        start_msg = self.getOutput([self.service, 'identity', 'start'])
        status = self.getOutput([self.service, 'identity', 'status'])
        if 'Jetty running pid' not in status:
            logging.error("Couldn't stop Identity.")
            logging.error(start_msg)

    def exportInstallData(self):
        logging.info("Exporting LDAP data.")
        if self.ldap_type == 'openldap':
            output = self.getOutput([self.slapcat, '-f', self.slapdConf,
                                     '-l', self.currentData])
        elif self.ldap_type == 'opendj':
            output = self.getOutput(
                [self.ldif_export, '-n', 'userRoot', '-l', self.currentData])
        else:
            output = "No LDAP configured."
        logging.debug(output)

    def convertSchema(self, f):
        infile = open(f, 'r')
        output = ""

        atypeRegex = re.compile('^attributeTypes:\s', re.IGNORECASE)
        obclassRegex = re.compile('^objectClasses:\s', re.IGNORECASE)

        isOCcontinue = False

        for line in infile:
            if isOCcontinue:
                if line[-1:] == ')':
                    isOCcontinue = False
                else:
                    isOCcontinue = True
                continue
            line = line.replace("X-SCHEMA-FILE '100-user.ldif'",
                                "X-SCHEMA-FILE 'custom.schema'")
            line = line.replace("X-SCHEMA-FILE '99-user.ldif'",
                                "X-SCHEMA-FILE 'custom.schema'")
            line = line.replace("'gluu' )",
                                "'Gluu - custom person attribute' )")

            if re.match('^dn:', line) or re.match('^objectClass:', line) or \
                    re.match('^cn:', line):
                continue
            # empty lines and the comments are copied as such
            if re.match('^#', line) or re.match('^\s*$', line):
                pass
            elif re.match('^\s\s', line):  # change the space indent to tabs
                line = re.sub('^\s\s', '\t', line)
            elif re.match('^\s', line):
                line = re.sub('^\s', '\t', line)
            # Change the keyword for attributetype
            elif atypeRegex.match(line):
                line = atypeRegex.sub('\nattributetype ', line, 1)
                oid = 'oxAttribute:' + str(self.attrs + 1)
                oidregex = re.compile('\s[\d]+\s', re.IGNORECASE)
                line = oidregex.sub(' ' + oid + ' ', line, 1)
                self.attrs += 1
            # Change the keyword for objectclass
            elif obclassRegex.match(line):
                if 'SUP gluuPerson' in line and 'objectClass MAY' in line:
                    att = re.search(r'\((.*?)\)', line.split('objectClass MAY')[1]).group(1)
                    self.customAttrs.append(att)
                    continue
                elif 'SUP gluuPerson' in line and 'objectClass MUST' in line:
                    att = re.search(r'\((.*?)\)', line.split('objectClass MUST')[1]).group(1)
                    self.customAttrs.append(att)
                    continue
                else:
                    if line[-1:] == ')':
                        isOCcontinue = False
                    else:
                        isOCcontinue = True
                continue
            else:
                logging.debug("Skipping Line: {}".format(line.strip()))
                line = ""

            output += line

        infile.close()
        return output

    def updateUserSchema(self, infile, outfile):
        with open(infile, 'r') as olduser:
            with open(outfile, 'w') as newuser:
                for line in olduser:
                    if 'SUP top' in line:
                        line = line.replace('SUP top', 'SUP gluuPerson')
                    newuser.write(line)

    def copyCustomSchema(self):
        logging.info("Converting Schema files of custom attributes.")
        loc = os.path.join(self.backupDir, 'opt', 'opendj', 'config', 'schema')
        schema_99 = os.path.join(loc, '99-user.ldif')
        schema_100 = os.path.join(loc, '100-user.ldif')

        if self.ldap_type == 'opendj':
            if os.path.isfile(schema_99):
                shutil.copyfile(
                    schema_99, '/opt/opendj/config/schema/99-user.ldif')
            if os.path.isfile(schema_100):
                shutil.copyfile(
                    schema_100, '/opt/opendj/config/schema/100-user.ldif')
                    
        
            #MB: ??
            #return

        #MB: add $ imapHost $ imapPort $ imapUsername $ imapPassword $ gluuPermission  to 77-customAttributes.ldif: gluuCustomPerson
        
        schema_77 = OpenDjSchema('/opt/opendj/config/schema/77-customAttributes.ldif')
        gluuCustomPerson = schema_77.get_class_by_name('gluuCustomPerson')
        may_list = list(gluuCustomPerson.may)
        for a in ['imapHost', 'imapPort', 'imapUsername', 'imapPassword', 'gluuPermission']:
            if not a in may_list:
                may_list.append(a)
        gluuCustomPerson.may = tuple(may_list)
        schema_77.write()
        
        #MB: add attribute oxSectorIdentifierURI to 101-ox.ldif
        
        schema_101 = OpenDjSchema('/opt/opendj/config/schema/101-ox.ldif')
        schema_101.add_attribute(
                    oid='oxSectorIdentifierURI-oid',
                    names=['oxSectorIdentifierURI'],
                    syntax='1.3.6.1.4.1.1466.115.121.1.15',
                    origin='Gluu created attribute',
                    desc='ox Sector Identifier URI',
                    equality='caseIgnoreMatch',
                    substr='caseIgnoreSubstringsMatch',
                    )
        schema_101.add_attribute_to_class('pairwiseIdentifier', 'oxSectorIdentifierURI')
        schema_101.add_attribute_to_class('oxAuthUmaScopeDescription', 'oxUrl')
        schema_101.write()
        

        #MB: I did not understand why we are doing followings

        """

        # Process for openldap and then append the contents to custom schema
        new_user = os.path.join(self.workingDir, 'new_99.ldif')
        custom_schema = os.path.join(self.gluuSchemaDir, 'custom.schema')
        output = ""

        if os.path.isfile(schema_99):
            output = self.convertSchema(schema_100)
            self.updateUserSchema(schema_99, new_user)
            output = output + "\n" + self.convertSchema(new_user)
        else:
            # If there is no 99-user file, then the schema def is in 100-user
            self.updateUserSchema(schema_100, new_user)
            output = self.convertSchema(new_user)

        outfile2 = open(os.path.join(self.gluuSchemaDir, 'custom.schema'), 'r')
        temp_schema = outfile2.read()
        custArrtributes = ''
        for indx, line in enumerate(self.customAttrs):
            custArrtributes = custArrtributes + ' $ ' + line
        if len(self.customAttrs) > 0:
            customAttrs = set(custArrtributes.split(' $ '))
        else:
            customAttrs = []
        custArrtributes = ""
        if len(self.customAttrs) > 0:
            for indx, line in enumerate(self.customAttrs):
                if indx == 0:
                    custArrtributes = custArrtributes + " $ " + line
                elif (indx < len(self.customAttrs) - 1):
                    custArrtributes = custArrtributes + line + " $ "
                else:
                    custArrtributes = custArrtributes + line
        print custArrtributes

        temp_schema = temp_schema.replace(
            re.search(r'\((.*?)\)', temp_schema.split('MAY')[1]).group(1),
            re.search(r'\((.*?)\)', temp_schema.split('MAY')[1]).group(1) + custArrtributes)
        outfile2.close()
        outfile = open(custom_schema, 'w')
        outfile.write(output + "\n" + temp_schema)
        outfile.close()

        eduperson = ""
        eduPath = os.path.join("/opt", "symas", "etc", "openldap", "schema", "eduperson.schema")
        input_file = open(eduPath)
        try:
            for i, line in enumerate(input_file):
                if i == 62:
                    line = line + "\n" + "attributetype ( 1.3.6.1.4.1.5923.1.1.1.9"
                    line = line + "\n" + "\t\tNAME 'eduPersonScopedAffiliation'"
                    line = line + "\n" + "\t\tDESC 'eduPerson per Internet2 and EDUCAUSE'"
                    line = line + "\n" + "\t\tEQUALITY caseIgnoreMatch"
                    line = line + "\n" + "\t\tSYNTAX '1.3.6.1.4.1.1466.115.121.1.15' SINGLE-VALUE )"
                    line = line + "\n"
                    line = line + "\n" + "attributetype ( 1.3.6.1.4.1.5923.1.1.1.10"
                    line = line + "\n" + "\t\tNAME 'eduPersonTargetedID'"
                    line = line + "\n" + "\t\tDESC 'eduPerson per Internet2 and EDUCAUSE'"
                    line = line + "\n" + "\t\tEQUALITY caseIgnoreMatch"
                    line = line + "\n" + "\t\tSYNTAX '1.3.6.1.4.1.1466.115.121.1.15' SINGLE-VALUE )"
                    line = line + "\n"
                    line = line + "\n" + "attributetype ( 1.3.6.1.4.1.5923.1.1.1.11"
                    line = line + "\n" + "\t\tNAME 'eduPersonAssurance'"
                    line = line + "\n" + "\t\tDESC 'eduPerson per Internet2 and EDUCAUSE'"
                    line = line + "\n" + "\t\tEQUALITY caseIgnoreMatch"
                    line = line + "\n" + "\t\tSYNTAX '1.3.6.1.4.1.1466.115.121.1.15' SINGLE-VALUE )"
                    line = line + "\n\n"
                if i == 63:
                    line = "\n" + line
                if i == 67:
                    line = line + "\t\teduPersonScopedAffiliation $ eduPersonTargetedID $ eduPersonAssurance $\n"
                eduperson = eduperson + line
        except Exception, e:
            logging.log(e)
        finally:
            input_file.close()
            f = open(eduPath, "w")
            f.write(eduperson)
        """
    def getEntry(self, fn, dn):
        parser = MyLDIF(open(fn, 'rb'), sys.stdout)
        parser.targetDN = dn
        parser.parse()
        return parser.targetEntry

    def getDns(self, fn):
        parser = MyLDIF(open(fn, 'rb'), sys.stdout)
        parser.parse()
        return parser.DNs

    def getOldEntryMap(self):
        files = os.listdir(self.ldifDir)
        dnMap = {}

        # get the new admin DN
        admin_ldif = '/install/community-edition-setup/output/people.ldif'
        admin_dn = self.getDns(admin_ldif)[0]

        for fn in files:
            dnList = self.getDns(os.path.join(self.ldifDir, fn))
            for dn in dnList:
                # skip the entry of Admin DN
                if fn == 'people.ldif' and admin_dn in dn:
                    continue
                dnMap[dn] = fn
        return dnMap

    def convertTimeStamp(self, line):
        dateString = line.replace('oxAuthAuthenticationTime:', '').strip()
        try:
            dateTimestamp = time.mktime(time.strptime(dateString, "%a %b %d %H:%M:%S %Z %Y"))
            dateString = time.strftime("%Y%m%d%H%M%S", time.gmtime(dateTimestamp))
            ts = time.time()
            utc_offset = (datetime.datetime.fromtimestamp(ts) - datetime.datetime.utcfromtimestamp(ts)).total_seconds()
            dateString = "%s.%03dZ" % (
                time.strftime("%Y%m%d%H%M%S", time.localtime(dateTimestamp)), int(utc_offset // 60))
        except ValueError:
            # Data from OpenLDAP would already be in the expected format.
            # The above parsing would happen only for data from OpenDJ.
            pass
        return "%s: %s\n" % ('oxAuthAuthenticationTime', dateString)

    def convertRefreshLastUpdate(self, line):
        dateString = line.replace('gluuVdsCacheRefreshLastUpdate: ', '').strip()
        try:
            dateTimestamp = time.mktime(time.strptime(dateString, "%a %b %d %H:%M:%S %Z %Y"))
            dateString = time.strftime("%Y%m%d%H%M%S", time.gmtime(dateTimestamp))
            ts = time.time()
            utc_offset = (datetime.datetime.fromtimestamp(ts) - datetime.datetime.utcfromtimestamp(ts)).total_seconds()
            dateString = "%s.%03dZ" % (
                time.strftime("%Y%m%d%H%M%S", time.localtime(dateTimestamp)), int(utc_offset // 60))
        except ValueError:
            # Data from OpenLDAP would already be in the expected format.
            # The above parsing would happen only for data from OpenDJ.
            pass
        return "%s: %s\n" % ('gluuVdsCacheRefreshLastUpdate', dateString)

    def processBackupData(self):
        logging.info('Processing the LDIF data.')

        processed_fp = open(self.processTempFile, 'w')
        ldif_writer = LDIFWriter(processed_fp)

        currentDNs = self.getDns(self.currentData)
        old_dn_map = self.getOldEntryMap()

        ignoreList = ['objectClass', 'ou', 'oxIDPAuthentication',
                      'gluuFreeMemory', 'gluuSystemUptime',
                      'oxLogViewerConfig', 'gluuLastUpdate']
        multivalueAttrs = ['oxTrustEmail', 'oxTrustPhoneValue', 'oxTrustImsValue',
                           'oxTrustPhotos', 'oxTrustAddresses', 'oxTrustRole',
                           'oxTrustEntitlements', 'oxTrustx509Certificate']

        if self.ldap_type == 'opendj':
            ignoreList.remove('oxIDPAuthentication')

        # Rewriting all the new DNs in the new installation to ldif file
        for dn in currentDNs:
            new_entry = self.getEntry(self.currentData, dn)
            if "o=site" in dn:
                continue  # skip all the o=site DNs
            if dn not in old_dn_map.keys():
                #  Write to the file if there is no matching old DN data
                ldif_writer.unparse(dn, new_entry)
                continue

            old_entry = self.getEntry(os.path.join(self.ldifDir, old_dn_map[dn]), dn)
            for attr in old_entry.keys():
                if attr in ignoreList:
                    continue

                if attr not in new_entry:
                    new_entry[attr] = old_entry[attr]
                elif old_entry[attr] != new_entry[attr]:
                    if len(old_entry[attr]) == 1:
                        try:
                            old_json = json.loads(old_entry[attr][0])
                            new_json = json.loads(new_entry[attr][0])
                            new_json = merge(new_json, old_json)
                            new_entry[attr] = [json.dumps(new_json)]
                        except:
                            if attr == 'oxScript':
                                new_entry[attr] = new_entry[attr]
                                logging.debug("Keeping new value for %s", attr)
                            else:
                                new_entry[attr] = old_entry[attr]
                                logging.debug("Keeping old value for %s", attr)
                    else:
                        new_entry[attr] = old_entry[attr]
                        logging.debug("Keep multiple old values for %s", attr)
            ldif_writer.unparse(dn, new_entry)

        # Pick all the left out DNs from the old DN map and write them to the LDIF
        for dn in sorted(old_dn_map, key=len):
            if "o=site" in dn:
                continue  # skip all the o=site DNs
            if dn in currentDNs:
                continue  # Already processed

            entry = self.getEntry(os.path.join(self.ldifDir, old_dn_map[dn]), dn)

            for attr in entry.keys():
                if attr not in multivalueAttrs:
                    continue  # skip conversion

                attr_values = []
                for val in entry[attr]:
                    json_value = None
                    try:
                        json_value = json.loads(val)
                        if type(json_value) is list:
                            attr_values.extend([json.dumps(v) for v in json_value])
                        else:
                            attr_values.append(val)
                    except:
                        logging.debug('Cannot parse multival %s in DN %s', attr, dn)
                        attr_values.append(val)
                entry[attr] = attr_values

            if 'oxAuthClientCustomAttributes' in entry['objectClass']:
                entry['objectClass'].remove('oxAuthClientCustomAttributes')

            ldif_writer.unparse(dn, entry)

        # Finally
        processed_fp.close()

        # Update the Schema change for lastModifiedTime
        with open(self.processTempFile, 'r') as infile:
            with open(self.o_gluu, 'w') as outfile:
                for line in infile:
                    line = line.replace("lastModifiedTime", "oxLastAccessTime")
                    line = line.replace('oxAuthUmaResourceSet', 'oxUmaResource')
                    if ("gluuAttributeOrigin:" in line and line.split("gluuAttributeOrigin: ")[1][:3] == 'ox-'):
                        line = 'gluuAttributeOrigin: gluuCustomPerson' + '\n'
                    if ("gluuAttributeOrigin:" in line and 'inetOrgPerson' in line):
                        line = 'gluuAttributeOrigin: gluuCustomPerson' + '\n'
                    if 'oxAuthAuthenticationTime' in line:
                        line = self.convertTimeStamp(line)
                    if 'oxAuthenticationMode' in line:
                        line = 'oxAuthenticationMode: auth_ldap_server' + '\n'
                    if 'oxTrustAuthenticationMode' in line:
                        line = 'oxTrustAuthenticationMode: auth_ldap_server'+ '\n'
                    if ("objectClass:" in line and line.split("objectClass: ")[1][:3] == 'ox-'):
                        line = line.replace(line, 'objectClass: gluuCustomPerson' + '\n')
                    if 'oxType' not in line and 'gluuVdsCacheRefreshLastUpdate' not in line and 'objectClass: person' not in line and 'objectClass: organizationalPerson' not in line and 'objectClass: inetOrgPerson' not in line:
                        outfile.write(line)
                    # parser = MyLDIF(open(self.currentData, 'rb'), sys.stdout)
                    # atr = parser.parse()
                    base64Types = [""]
                    # for idx, val in enumerate(parser.entries):
                    # if 'displayName' in val:
                    #     if val['displayName'][0] == 'SCIM Resource Set':
                    #         out = CreateLDIF(parser.getDNs()[idx], val,
                    #                          base64_attrs=base64Types)
                    #         f = open(self.o_gluu, "a")
                    #         f.write('\n')
                    #         f.write(out)
        #data="".join(open( os.path.join(self.backupDir, 'ldif','site.ldif')).readlines()[4:-1])
        #open(os.path.join(self.backupDir, 'ldif','sitetmp.ldif'),"wb").write(data)
        #filenames = [self.o_site_static, os.path.join(self.backupDir, 'ldif','sitetmp.ldif')]
        #with open(self.o_site, 'w') as outfile:
        #    for fname in filenames:
        #        with open(fname) as infile:
        #            for line in infile:
        #                outfile.write(line)
        #os.remove(os.path.join(self.backupDir, 'ldif','sitetmp.ldif'))
    def importDataIntoOpenldap(self):
        count = len(os.listdir('/opt/gluu/data/main_db/')) - 1
        backupfile = self.ldapDataFile + ".bkp_{0:02d}".format(count)
        logging.debug("Moving %s to %s.", self.ldapDataFile, backupfile)
        try:
            shutil.move(self.ldapDataFile, backupfile)
        except IOError:
            logging.debug(traceback.format_exc())

        count = len(os.listdir('/opt/gluu/data/site_db/')) - 1
        backupfile = self.ldapSiteFile + ".bkp_{0:02d}".format(count)
        logging.debug("Moving %s to %s.", self.ldapSiteFile, backupfile)
        try:
            shutil.move(self.ldapSiteFile, backupfile)
        except IOError:
            logging.debug(traceback.format_exc())

        output = self.getOutput([self.slapadd, '-c', '-b', 'o=gluu', '-f',
                                 self.slapdConf, '-l', self.o_gluu])
        logging.debug(output)
        output = self.getOutput([self.slapadd, '-c', '-b', 'o=site', '-f',
                                 self.slapdConf, '-l', self.o_site])
        logging.debug(output)

    def importDataIntoOpenDJ(self):
        command = [self.ldif_import, '-n', 'userRoot',
                   '-l', self.o_gluu, '-R', self.o_gluu + '.rejects']
        output = self.getOutput(command)
        logging.debug(output)
        #command = [self.ldif_import, '-n', 'userRoot',
        #           '-l', self.o_site, '-R', self.o_site + '.rejects']
        #command = [self.ldif_import, '-n', 'site',
        #           '-l', self.o_site, '-R', self.o_site + '.rejects']
        #output = self.getOutput(command)
        #logging.debug(output)

    def importProcessedData(self):
        logging.info("Importing Processed LDAP data.")
        if self.ldap_type == 'openldap':
            self.importDataIntoOpenldap()
        else:
            self.importDataIntoOpenDJ()

    def getLDAPServerType(self):

        choice = 0
        if os.path.isfile(self.setup_properties):
            data = ""
            try:
                with open(self.setup_properties) as f:
                    for line in f:
                        if line == 'ldap_type=openldap\n':
                            choice = 1
                        elif line == 'ldap_type=opendj\n':
                            choice = 2
            except:
                logging.error(self.setup_properties+" File not Found")
                sys.exit(0)

        if choice == 1:
            self.ldap_type = 'openldap'
        elif choice == 2:
            self.ldap_type = 'opendj'
        else:
            logging.error("Invalid selection of LDAP Server. Cannot Migrate.")
            sys.exit(1)

    def stopOpenDJ(self):
        logging.info('Stopping OpenDJ Directory Server...')
        if (os.path.isfile('/usr/bin/systemctl')):
            self.getOutput(['systemctl', 'stop', 'opendj'])
            output = self.getOutput(['systemctl', 'is-active', 'opendj'])
        else:
            output = self.getOutput([self.service, 'opendj', 'stop'])

        if output.find("Directory Server is now stopped") > 0 or \
                        output.strip() == "failed":
            logging.info("Directory Server is now stopped")
        else:
            logging.error(
                "OpenDJ did not stop properly. Import cannot run without "
                "stopping the directory server. Exiting from import. Check"
                " /opt/opendj/logs/errors")
            sys.exit(1)

    def startOpenDJ(self):
        logging.info('Starting OpenDJ Directory Server...')
        if (os.path.isfile('/usr/bin/systemctl')):
            self.getOutput(['systemctl', 'start', 'opendj'])
            output = self.getOutput(['systemctl', 'is-active', 'opendj'])
            if output.find("Directory Server has started successfully") > 0 or \
                            output.strip() == "active":
                logging.info("Directory Server has started successfully")
        else:
            # start opendj through service
            output = self.getOutput([self.service, 'opendj', 'start'])
            if output != "":
                logging.error("OpenDJ did not start properly. Check "
                              "/opt/opendj/logs/errors. Restart it manually.")
                sys.exit(1)


    def stopLDAPServer(self):
        if self.ldap_type == 'openldap':
            self.stopSolserver()
        else:
            self.stopOpenDJ()

    def startLDAPServer(self):

        if self.ldap_type == 'openldap':
            self.startSolserver()
        else:
            self.startOpenDJ()

    def copyIDPFiles(self):
        idp_dir = os.path.join(self.backupDir, 'opt', 'idp')
        if os.path.isdir(idp_dir):
            logging.info('Copying Shibboleth IDP files...')
            if os.path.isdir(os.path.join(idp_dir, 'metadata')):
                copy_tree(
                    os.path.join(self.backupDir, 'opt', 'idp', 'metadata'),
                    '/opt/shibboleth-idp/metadata')
            if os.path.isdir(os.path.join(idp_dir, 'ssl')):
                copy_tree(
                    os.path.join(self.backupDir, 'opt', 'idp', 'ssl'),
                    '/opt/shibboleth-idp/ssl')

    def fixPermissions(self):
        logging.info('Fixing permissions for files.')
        if self.ldap_type == 'openldap':
            self.getOutput(['chown', 'ldap:ldap', self.ldapDataFile])
            self.getOutput(['chown', 'ldap:ldap', self.ldapSiteFile])

    def getProp(self, prop, prop_file=None):
        if not prop_file:
            prop_file = os.path.join(self.backupDir, 'setup.properties')

        with open(prop_file, 'r') as f:
            for line in f:
                n = line.find('=')
                if n > -1:
                    if line[:n]==prop:
                        tmp = line[n+1:].strip()
                        return tmp.replace('\\=','=')

    def unobscure(self,s=""):
        engine = pyDes.triple_des(self.key, pyDes.ECB, pad=None, padmode=pyDes.PAD_PKCS5)
        cipher = pyDes.triple_des(self.key)
        decrypted = cipher.decrypt(base64.b64decode(s), padmode=pyDes.PAD_PKCS5)
        return decrypted

    def getLdapPassword(self):

        try:
            with open('/etc/gluu/conf/ox-ldap.properties') as f:
                for line in f:
                    if line.startswith("bindPassword:"):
                        self.ldappassowrd = line.split(":")[1].split("\n")[0].strip()

        except:
            logging.error("ox-ldap.properties file not Found")


        #get salt key
        saltFn = "/etc/gluu/conf/salt"
        try:
            f = open(saltFn)
            salt_property = f.read()
            f.close()
            self.key = salt_property.split("=")[1].strip()
            self.ldappassowrd = self.unobscure(self.ldappassowrd)
            #print self.ldappassowrd

        except:
            logging.error("Salt key Access Error")


    def idpResolved(self):

        logging.info('Idp Configuration Setting...')
        self.getLdapPassword()

        if self.ldap_type == 'opendj':
            self.baseDn = "cn=directory manager"

        self.oxAuthClientSecret = self.getProp('oxauthClient_encoded_pw', 
                    '/install/community-edition-setup/setup.properties.last')

        oxauth_client_id = self.getProp('oxauth_client_id', 
                    '/install/community-edition-setup/setup.properties.last')

        inumOrg = self.getProp('inumOrg', 
                    '/install/community-edition-setup/setup.properties.last')
        
        inumAppliance = self.getProp('inumAppliance', 
                    '/install/community-edition-setup/setup.properties.last')
        
        con = ldap.initialize('ldaps://{}:{}'.format(self.ldapHost, self.ldapPort))
        con.simple_bind_s(self.baseDn, self.ldappassowrd)

        dn = 'inum={},ou=clients,o={},o=gluu'.format(oxauth_client_id, inumOrg)
        
        con.modify_s(dn, [( ldap.MOD_REPLACE, 'oxAuthClientSecret', self.oxAuthClientSecret)])
        
        dn = 'ou=oxtrust,ou=configuration,inum={},ou=appliances,o=gluu'.format(inumAppliance)

        results = con.search_s(dn,  ldap.SCOPE_BASE, attrlist=['oxTrustConfApplication'])

        jsons = results[0][1]['oxTrustConfApplication'][0]
        jdata = json.loads(jsons)
        jdata['oxAuthClientPassword']= self.oxAuthClientSecret
        jsons = json.dumps(jdata)

        con.modify_s(dn, [( ldap.MOD_REPLACE, 'oxTrustConfApplication',  jsons)])
        
        #MB: I don't know which of the following is reuired
        """
        command = [self.ldif_search,'-h',self.ldapHost,'-p',self.ldapPort,'-s','sub','-T','-Z','-X','-D',self.baseDn,'-w',self.ldappassowrd,'-b','o=gluu','-z', '3','&(objectclass=oxauthclient)(displayName=oxTrust Admin GUI)','oxAuthClientSecret']
        output = self.getOutput(command)

        outSplit = output.split(': ')
        self.oxAuthClientSecret = outSplit[2].split('\n\n')[0]

        command = [self.ldif_search,'-h',self.ldapHost,'-p',self.ldapPort,'-s','sub','-T','-Z','-X','-D',self.baseDn,'-w',self.ldappassowrd,'-b','o=gluu','-z', '3','&(objectclass=oxapplicationconfiguration)','1.1']
        output = self.getOutput(command)

        self.idpDN = output


        idp_conf_command = self.ldif_search+' -h '+self.ldapHost+' -p '+self.ldapPort+' -s sub -T -Z -X -D '+"'"+self.baseDn+"'"+' -w '+self.ldappassowrd+" -b 'o=gluu' -z 3 '&(objectclass=oxapplicationconfiguration)' oxConfApplication | grep -v '^dn\:\ ' | cut -d' ' -f2 | base64 -d > idp_conf.json"
        os.system(idp_conf_command)

        output = self.getOutput(['chmod','777','-R','idp_conf.json'])


        #change openIdClientPassword with oxAuthClientSecret
        file = "idp_conf.json"
        data = ""
        try:
            with open(file) as f:
                for line in f:
                    data += line
        except:
            logging.error("Error reading idp_conf.json Template")
            logging.error(traceback.format_exc())
            sys.exit(1)

        datastore = json.loads(data)
        datastore['openIdClientPassword'] = self.oxAuthClientSecret

        try:
            with open(file, 'w') as outfile:
                json.dump(datastore, outfile,indent=4)
        except:
            logging.error("Error writting idp_conf.json Template")
            logging.error(traceback.format_exc())
            sys.exit(1)

        self.encryptIdpJson  = os.popen('cat idp_conf.json | base64 -w 0; echo').read()
        getdn = self.idpDN.split('\n\n')

        fileLdif = "idpconf_upd.ldif"
        try:
            file = open(fileLdif,'w')
            file.write(getdn[0]+"\n")
            file.write("changetype: modify\n")
            file.write("replace: oxConfApplication\n")
            file.write("oxConfApplication:: "+self.encryptIdpJson)
            file.close()
        except:
            logging.error("Error writting idpconf_upd.ldif Template")
            sys.exit(1)


        command = [self.ldif_modify,'-h',self.ldapHost,'-p',self.ldapPort,'-Z','-X','-D',self.baseDn,'-w',self.ldappassowrd,'-f','idpconf_upd.ldif']
        output = self.getOutput(command)

        # CR bindDN = cn=directory manager set opendj time
        if self.ldap_type == 'opendj':

            command = [self.ldif_search,'-h',self.ldapHost,'-p',self.ldapPort,'-s','sub','-T','-Z','-X','-D',self.baseDn,'-w',self.ldappassowrd,'-b','o=gluu','&(objectclass=oxtrustconfiguration)','oxTrustConfCacheRefresh']
            output = self.getOutput(command)
            oxtrustconfcacherefreshDn = output.split('\n')

            valueget = oxtrustconfcacherefreshDn[1].split('oxTrustConfCacheRefresh: ')
            data = json.loads(valueget[1])
            data["inumConfig"]["bindDN"] = "cn=directory manager"

            fileLdif = "oxtrustconfcacherefreshDn.json"
            try:
                with open(fileLdif, 'w') as outfile:
                    json.dump(data, outfile,indent=4)
            except:
                logging.error("Error writting oxtrustconfcacherefreshDn.json Template")

            self.encryptIdpJson  = os.popen('cat oxtrustconfcacherefreshDn.json | base64 -w 0; echo').read()

            fileLdif = "oxtrustconfcacherefreshDn.ldif"
            try:
                file = open(fileLdif,'w')
                file.write(oxtrustconfcacherefreshDn[0]+"\n")
                file.write("changetype: modify\n")
                file.write("replace: oxTrustConfCacheRefresh\n")
                file.write("oxTrustConfCacheRefresh:: "+self.encryptIdpJson)
                file.close()
            except:
                logging.error("Error writting oxtrustconfcacherefreshDn.ldif Template")


        command = [self.ldif_modify,'-h',self.ldapHost,'-p',self.ldapPort,'-Z','-X','-D',self.baseDn,'-w',self.ldappassowrd,'-f','oxtrustconfcacherefreshDn.ldif']
        output = self.getOutput(command)
        #end here

        
        command = ['cp','/etc/certs/shibIDP.crt','/etc/certs/idp-signing.crt']
        output = self.getOutput(command)

        command = ['cp','/etc/certs/shibIDP.key','/etc/certs/idp-signing.key']
        output = self.getOutput(command)

        command = ['service','idp','restart']
        output = self.getOutput(command)
        """

    def migrate(self):
        """Main function for the migration of backup data
        """
        print("\n")
        print("------------------------------------------------------------")
        print("        Gluu Server Community Edition Migration Tool        ")
        print("============================================================")
        self.version = int(self.getProp('version').replace('.', '')[0:3])
        self.getLDAPServerType()
        self.verifyBackupData()
        self.setupWorkDirectory()
        #self.stopWebapps()
        #self.stopLDAPServer()
        #self.importDataIntoOpenDJ()
        #self.copyCertificates()
        #self.copyCustomFiles()
        #self.copyIDPFiles()
        if self.version < 300 or self.ldap_type == 'opendj':
            self.copyCustomSchema()
        self.exportInstallData()
        self.processBackupData()
        self.importProcessedData()
        #self.fixPermissions()
        self.startLDAPServer()
        self.idpResolved()
        #self.startWebapps()
        print("============================================================")
        print("The migration is complete. Gluu Server needs to be restarted.")
        print("\n\n\t# logout\n\t# service gluu-server-x.x.x restart\n")
        print("------------------------------------------------------------")
        print("\n")


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print "Usage: ./import2431.py <path_to_backup_folder>"
        print "Example:\n ./import2431.py /root/backup_2431"
    else:
        migrator = Migration(sys.argv[1])
        migrator.migrate()

